diff --git a/srsue/src/upper/nas.cc b/srsue/src/upper/nas.cc
index d1d245a0..d3d197e0 100644
--- a/srsue/src/upper/nas.cc
+++ b/srsue/src/upper/nas.cc
@@ -157,7 +157,7 @@ bool nas::attach_request() {
       if (plmn_is_selected) {
         rrc->plmn_select(current_plmn);
         if (rrc_connect()) {
-          nas_log->info("NAS attached successfully.\n");
+          nas_log->info("NAS attached successfully. DEREG tx_count=%d\n", ctxt.tx_count);
           return true;
         } else {
           nas_log->error("Could not attach in attach request\n");
@@ -173,7 +173,7 @@ bool nas::attach_request() {
       } else {
         nas_log->info("NAS is already registered but RRC disconnected. Connecting now...\n");
         if (rrc_connect()) {
-          nas_log->info("NAS attached successfully.\n");
+          nas_log->info("NAS attached successfully. REG tx_count=%d\n", ctxt.tx_count);
           return true;
         } else {
           nas_log->error("Could not attach from attach_request\n");
@@ -252,7 +252,8 @@ bool nas::rrc_connect() {
       tout++;
     }
     if (state == EMM_STATE_REGISTERED) {
-      nas_log->info("EMM Registered correctly\n");
+      ctxt.tx_count++;
+      nas_log->info("EMM Registered correctly, tx_count=%d\n", ctxt.tx_count);
       return true;
     } else if (state == EMM_STATE_DEREGISTERED) {
       nas_log->error("Timeout or received attach reject while trying to attach\n");
@@ -381,8 +382,14 @@ uint32_t nas::get_ul_count() {
   // UL count for RRC key derivation depends on ESM information transfer procedure
   if (cfg.apn.empty()) {
     // No ESM info transfer has been sent
+    if(ctxt.tx_count < 1)
+      nas_log->error("XXX get_ul_count error result will be < 0\n");
+
     return ctxt.tx_count - 1;
   } else {
+    if(ctxt.tx_count < 2)
+      nas_log->error("XXX get_ul_count error result will be < 0\n");
+
     return ctxt.tx_count - 2;
   }
 }
@@ -592,7 +599,8 @@ void nas::parse_attach_accept(uint32_t lcid, byte_buffer_t *pdu) {
   LIBLTE_MME_ACTIVATE_DEFAULT_EPS_BEARER_CONTEXT_ACCEPT_MSG_STRUCT act_def_eps_bearer_context_accept;
   ZERO_OBJECT(act_def_eps_bearer_context_accept);
 
-  nas_log->info("Received Attach Accept\n");
+  ctxt.tx_count++;
+  nas_log->info("Received Attach Accept, tx_count=%d\n", ctxt.tx_count);
 
   liblte_mme_unpack_attach_accept_msg((LIBLTE_BYTE_MSG_STRUCT *) pdu, &attach_accept);
 
@@ -721,9 +729,9 @@ void nas::parse_attach_accept(uint32_t lcid, byte_buffer_t *pdu) {
     // Instruct RRC to enable capabilities
     rrc->enable_capabilities();
 
-    nas_log->info("Sending Attach Complete\n");
+    nas_log->info("Sending Attach Complete tx_count=%d\n", ctxt.tx_count);
     rrc->write_sdu(lcid, pdu);
-    ctxt.tx_count++;
+//  ctxt.tx_count++;
 
   } else {
     nas_log->info("Not handling attach type %u\n", attach_accept.eps_attach_result);
@@ -735,9 +743,10 @@ void nas::parse_attach_accept(uint32_t lcid, byte_buffer_t *pdu) {
 void nas::parse_attach_reject(uint32_t lcid, byte_buffer_t *pdu) {
   LIBLTE_MME_ATTACH_REJECT_MSG_STRUCT attach_rej;
   ZERO_OBJECT(attach_rej);
+  ctxt.tx_count++;
 
   liblte_mme_unpack_attach_reject_msg((LIBLTE_BYTE_MSG_STRUCT *) pdu, &attach_rej);
-  nas_log->warning("Received Attach Reject. Cause= %02X\n", attach_rej.emm_cause);
+  nas_log->warning("Received Attach Reject. Cause= %02X, tx_count=%d\n", attach_rej.emm_cause, ctxt.tx_count);
   nas_log->console("Received Attach Reject. Cause= %02X\n", attach_rej.emm_cause);
   state = EMM_STATE_DEREGISTERED;
   pool->deallocate(pdu);
@@ -791,7 +800,8 @@ void nas::parse_authentication_request(uint32_t lcid, byte_buffer_t *pdu) {
 }
 
 void nas::parse_authentication_reject(uint32_t lcid, byte_buffer_t *pdu) {
-  nas_log->warning("Received Authentication Reject\n");
+  ctxt.tx_count++;
+  nas_log->warning("Received Authentication Reject tx_count=%d\n", ctxt.tx_count);
   pool->deallocate(pdu);
   state = EMM_STATE_DEREGISTERED;
   // FIXME: Command RRC to release?
@@ -948,11 +958,12 @@ void nas::parse_security_mode_command(uint32_t lcid, byte_buffer_t *pdu)
                 ctxt.tx_count,
                 rrc->get_rb_name(lcid).c_str());
   rrc->write_sdu(lcid, pdu);
-  ctxt.tx_count++;
+//ctxt.tx_count++;
 }
 
 void nas::parse_service_reject(uint32_t lcid, byte_buffer_t *pdu) {
-  nas_log->error("TODO:parse_service_reject\n");
+  ctxt.tx_count++;
+  nas_log->error("TODO:parse_service_reject, tx_count=%d\n", ctxt.tx_count);
   pool->deallocate(pdu);
 }
 
@@ -989,7 +1000,7 @@ void nas::gen_attach_request(byte_buffer_t *msg) {
   LIBLTE_MME_ATTACH_REQUEST_MSG_STRUCT attach_req;
   bzero(&attach_req, sizeof(LIBLTE_MME_ATTACH_REQUEST_MSG_STRUCT));
 
-  nas_log->info("Generating attach request\n");
+  nas_log->info("Generating attach request tx_count=%d\n", ctxt.tx_count);
 
   attach_req.eps_attach_type = LIBLTE_MME_EPS_ATTACH_TYPE_EPS_ATTACH;
 
@@ -1063,9 +1074,9 @@ void nas::gen_attach_request(byte_buffer_t *msg) {
     pcap->write_nas(msg->msg, msg->N_bytes);
   }
 
-  if (have_ctxt) {
-    ctxt.tx_count++;
-  }
+//  if (have_ctxt) {
+//    ctxt.tx_count++;
+//  }
 }
 
 
@@ -1075,7 +1086,7 @@ void nas::gen_service_request(byte_buffer_t *msg) {
     return;
   }
 
-  nas_log->info("Generating service request\n");
+  nas_log->info("Generating service request tx_count=%d\n", ctxt.tx_count);
 
   // Pack the service request message directly
   msg->msg[0] = (LIBLTE_MME_SECURITY_HDR_TYPE_SERVICE_REQUEST << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
@@ -1101,7 +1112,7 @@ void nas::gen_service_request(byte_buffer_t *msg) {
     pcap->write_nas(msg->msg, msg->N_bytes);
   }
 
-  ctxt.tx_count++;
+//ctxt.tx_count++;
 }
 
 void nas::gen_pdn_connectivity_request(LIBLTE_BYTE_MSG_STRUCT *msg) {
@@ -1234,9 +1245,9 @@ void nas::send_service_request() {
     pcap->write_nas(msg->msg, msg->N_bytes);
   }
 
-  nas_log->info("Sending service request\n");
+  nas_log->info("Sending service request tx_count=%d\n", ctxt.tx_count);
   rrc->write_sdu(cfg.lcid, msg);
-  ctxt.tx_count++;
+//ctxt.tx_count++;
 }
 
 void nas::send_esm_information_response(const uint8 proc_transaction_id) {
@@ -1367,10 +1378,10 @@ void nas::send_esm_information_response(const uint8 proc_transaction_id) {
     return;
   }
 
-  nas_log->info_hex(pdu->msg, pdu->N_bytes, "Sending ESM information response\n");
+  nas_log->info_hex(pdu->msg, pdu->N_bytes, "Sending ESM information response tx_count=%d\n", ctxt.tx_count);
   rrc->write_sdu(cfg.lcid, pdu);
 
-  ctxt.tx_count++;
+//ctxt.tx_count++;
   chap_id++;
 }
 
