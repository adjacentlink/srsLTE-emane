diff --git a/srsepc/hdr/hss/hss.h b/srsepc/hdr/hss/hss.h
index a4334ef..7d7e2e8 100644
--- a/srsepc/hdr/hss/hss.h
+++ b/srsepc/hdr/hss/hss.h
@@ -67,7 +67,6 @@ typedef struct{
     uint8_t  sqn[6];
     uint16_t qci;
     uint8_t  last_rand[16];
-    std::string static_ip_addr;
 }hss_ue_ctx_t;
 
 enum hss_auth_algo {
@@ -88,8 +87,6 @@ public:
 
   virtual bool resync_sqn(uint64_t imsi, uint8_t *auts);
 
-  std::map<std::string, uint64_t> get_ip_to_imsi() const;
-
 private:
 
   hss();
@@ -135,8 +132,6 @@ private:
   
   uint16_t mcc;
   uint16_t mnc;
-
-  std::map<std::string, uint64_t> m_ip_to_imsi;
 };
 
 } // namespace srsepc
diff --git a/srsepc/hdr/spgw/spgw.h b/srsepc/hdr/spgw/spgw.h
index 9c09831..3222f51 100644
--- a/srsepc/hdr/spgw/spgw.h
+++ b/srsepc/hdr/spgw/spgw.h
@@ -40,8 +40,6 @@
 #include "srslte/common/buffer_pool.h"
 #include "srslte/common/threads.h"
 #include "srslte/asn1/gtpc.h"
-#include <map>
-#include <set>
 
 namespace srsepc{
 
@@ -72,7 +70,7 @@ class spgw:
 public:
   static spgw* get_instance(void);
   static void cleanup(void);
-  int init(spgw_args_t* args, srslte::log_filter *spgw_log, const std::map<std::string, uint64_t> & ip_to_imsi);
+  int init(spgw_args_t* args, srslte::log_filter *spgw_log);
   void stop();
   void run_thread();
 
@@ -92,11 +90,11 @@ private:
 
   srslte::error_t init_sgi_if(spgw_args_t *args);
   srslte::error_t init_s1u(spgw_args_t *args);
-  srslte::error_t init_ue_ip(spgw_args_t *args, const std::map<std::string, uint64_t> & ip_to_imsi);
+  srslte::error_t init_ue_ip(spgw_args_t *args);
 
   uint64_t get_new_ctrl_teid();
   uint64_t get_new_user_teid();
-  in_addr_t get_new_ue_ipv4(uint64_t imsi);
+  in_addr_t get_new_ue_ipv4();
 
   spgw_tunnel_ctx_t* create_gtp_ctx(struct srslte::gtpc_create_session_request *cs_req);
   bool delete_gtp_ctx(uint32_t ctrl_teid);
@@ -125,8 +123,7 @@ private:
   std::map<uint32_t,spgw_tunnel_ctx*> m_teid_to_tunnel_ctx;         //Map control TEID to tunnel ctx. Usefull to get reply ctrl TEID, UE IP, etc.
   std::map<in_addr_t,srslte::gtpc_f_teid_ie> m_ip_to_teid;          //Map IP to User-plane TEID for downlink traffic
 
-  std::set<uint32_t> m_ue_ip_addr_pool;
-  std::map<uint64_t, struct in_addr> m_imsi_to_ip;
+  uint32_t m_h_next_ue_ip;
 
   /*Time*/
   struct timeval m_t_last_dl;
diff --git a/srsepc/src/hss/hss.cc b/srsepc/src/hss/hss.cc
index b4dd819..959c042 100644
--- a/srsepc/src/hss/hss.cc
+++ b/srsepc/src/hss/hss.cc
@@ -154,9 +154,8 @@ hss::read_db_file(std::string db_filename)
     if(line[0] != '#')
     {
       uint column_size = 8;
-      uint column_size_2 = 9;  // optional static ip_addr
       std::vector<std::string> split = split_string(line,',');
-      if(split.size() != column_size && split.size() != column_size_2)
+      if(split.size() != column_size)
       {
         m_hss_log->error("Error parsing UE database. Wrong number of columns in .csv\n");
         m_hss_log->error("Columns: %zd, Expected %d.\n", split.size(), column_size);
@@ -195,26 +194,6 @@ hss::read_db_file(std::string db_filename)
       m_hss_log->debug_hex(ue_ctx->sqn, 6, "SQN : ");
       ue_ctx->qci = atoi(split[7].c_str());
       m_hss_log->debug("Default Bearer QCI: %d\n",ue_ctx->qci);
-
-      // optional imsi to ip
-      if(split.size() == column_size_2) {
-         char buf[128];
-         if(inet_ntop(AF_INET, split[8].c_str(), buf, sizeof(buf))) {
-           if(m_ip_to_imsi.insert(std::make_pair(split[8], ue_ctx->imsi)).second) {
-             ue_ctx->static_ip_addr = split[8];
-             m_hss_log->info("static ip addr %s\n", ue_ctx->static_ip_addr.c_str());
-           } else {
-             m_hss_log->info("duplicate static ip addr %s\n", split[8].c_str());
-             return false;
-           } 
-         } else {
-           m_hss_log->info("invalid static ip addr %s, %s\n", split[8].c_str(), strerror(errno));
-           return false;
-         }
-       } else {
-       ue_ctx->static_ip_addr = "0.0.0.0";
-     }
-
       m_imsi_to_ue_ctx.insert(std::pair<uint64_t,hss_ue_ctx_t*>(ue_ctx->imsi,ue_ctx));
     }
   }
@@ -283,12 +262,6 @@ bool hss::write_db_file(std::string db_filename)
       m_db_file << hex_string(it->second->sqn, 6);
       m_db_file << ",";
       m_db_file << it->second->qci;
-
-      // optional imsi to ip
-      if(it->second->static_ip_addr != "0.0.0.0"){
-        m_db_file << ",";
-        m_db_file << it->second->static_ip_addr;
-      }
       m_db_file << std::endl;
       it++;
   }
@@ -832,9 +805,4 @@ hss::hex_string(uint8_t *hex, int size)
   }
   return ss.str();
 }
-
-std::map<std::string, uint64_t> hss::get_ip_to_imsi(void) const
-{
-  return m_ip_to_imsi;
-}
 } //namespace srsepc
diff --git a/srsepc/src/main.cc b/srsepc/src/main.cc
index 3a2a61a..47e83b6 100644
--- a/srsepc/src/main.cc
+++ b/srsepc/src/main.cc
@@ -451,7 +451,7 @@ main (int argc,char * argv[] )
   }
 
   spgw *spgw = spgw::get_instance();
-  if (spgw->init(&args.spgw_args,&spgw_log, hss->get_ip_to_imsi())) {
+  if (spgw->init(&args.spgw_args,&spgw_log)) {
     cout << "Error initializing SP-GW" << endl;
     exit(1);
   }
diff --git a/srsepc/src/spgw/spgw.cc b/srsepc/src/spgw/spgw.cc
index fd0b723..497cd95 100644
--- a/srsepc/src/spgw/spgw.cc
+++ b/srsepc/src/spgw/spgw.cc
@@ -87,7 +87,7 @@ spgw::cleanup(void)
 }
 
 int
-spgw::init(spgw_args_t* args, srslte::log_filter *spgw_log, const std::map<std::string, uint64_t> & ip_to_imsi)
+spgw::init(spgw_args_t* args, srslte::log_filter *spgw_log)
 {
   srslte::error_t err;
   m_pool = srslte::byte_buffer_pool::get_instance();
@@ -112,7 +112,7 @@ spgw::init(spgw_args_t* args, srslte::log_filter *spgw_log, const std::map<std::
     return -1;
   }
   //Initialize UE ip pool
-  err = init_ue_ip(args, ip_to_imsi);
+  err = init_ue_ip(args);
   if (err != srslte::ERROR_NONE)
   {
     m_spgw_log->console("Could not initialize the S1-U interface.\n");
@@ -259,57 +259,9 @@ spgw::init_s1u(spgw_args_t *args)
 }
 
 srslte::error_t
-spgw::init_ue_ip(spgw_args_t *args, const std::map<std::string, uint64_t> & ip_to_imsi)
+spgw::init_ue_ip(spgw_args_t *args)
 {
-  std::map<std::string, uint64_t>::const_iterator iter = ip_to_imsi.find(args->sgi_if_addr);
-
-  // check for collision w/our ip address
-  if(iter != ip_to_imsi.end())
-    {
-      m_spgw_log->error("SPGW: static ip addr %s for imsi %lu, is reserved for the epc tun interface\n", 
-                        iter->first.c_str(), iter->second);
-
-      return srslte::ERROR_OUT_OF_BOUNDS;
-    }
-
-  // load our imsi to ip lookup table
-  for(std::map<std::string, uint64_t>::const_iterator iter = ip_to_imsi.begin(); iter != ip_to_imsi.end(); ++iter)
-    {
-      struct in_addr in_addr;
-
-      in_addr.s_addr = inet_addr(iter->first.c_str());
-
-      if(! m_imsi_to_ip.insert(std::make_pair(iter->second, in_addr)).second)
-        {
-          m_spgw_log->error("SPGW: duplicate imsi %lu for static ip address %s.\n", iter->second, iter->first.c_str());
-
-          return srslte::ERROR_OUT_OF_BOUNDS;
-        }
-    }
-
-  // XXX TODO add an upper bound to ip addr range via config, use 100 for now
-  // first address is allocated to the epc tun interface, start w/next addr
-  for(uint32_t n = 1; n < 100; ++n)
-   {
-     struct in_addr ue_addr;
-
-     ue_addr.s_addr = inet_addr(args->sgi_if_addr.c_str()) + htonl(n);
-
-     std::map<std::string, uint64_t>::const_iterator iter = ip_to_imsi.find(inet_ntoa(ue_addr));
-
-     if(iter != ip_to_imsi.end())
-      {
-        m_spgw_log->debug("SPGW: init_ue_ip ue ip addr %s is reserved for imsi %lu, not adding to pool\n", 
-                          iter->first.c_str(), iter->second);
-      }
-     else
-      {
-        m_ue_ip_addr_pool.insert(ue_addr.s_addr);
-
-        m_spgw_log->debug("SPGW: init_ue_ip ue ip addr %s is added to pool\n", inet_ntoa(ue_addr));
-      }
-   }
-
+  m_h_next_ue_ip = ntohl(inet_addr(args->sgi_if_addr.c_str()));
   return srslte::ERROR_NONE;
 }
 
@@ -462,39 +414,10 @@ spgw::get_new_user_teid()
 }
 
 in_addr_t
-spgw::get_new_ue_ipv4(uint64_t imsi)
+spgw::get_new_ue_ipv4()
 {
-   struct in_addr ue_addr;
-
-   std::map<uint64_t, struct in_addr>::const_iterator iter = m_imsi_to_ip.find(imsi);
-
-   // check imsi to ip mapping
-   if(iter != m_imsi_to_ip.end())
-     {
-       ue_addr = iter->second;
-
-       m_spgw_log->info("SPGW: get_new_ue_ipv4 static ip addr %s\n", inet_ntoa(ue_addr));
-     }
-   else
-     {
-       if(m_ue_ip_addr_pool.empty())
-        {
-          m_spgw_log->error("SPGW: ue address pool is empty\n");
-
-          ue_addr.s_addr = 0;
-        }
-     else
-       {
-         ue_addr.s_addr = *m_ue_ip_addr_pool.begin();
-
-         // now remove from pool 
-         m_ue_ip_addr_pool.erase(ue_addr.s_addr);
-
-         m_spgw_log->info("SPGW: get_new_ue_ipv4 pool ip addr %s\n", inet_ntoa(ue_addr));
-       }
-   }
-
-  return ue_addr.s_addr;
+  m_h_next_ue_ip++;
+  return ntohl(m_h_next_ue_ip);//FIXME Tmp hack
 }
 
 spgw_tunnel_ctx_t*
@@ -504,8 +427,9 @@ spgw::create_gtp_ctx(struct srslte::gtpc_create_session_request *cs_req)
   uint64_t spgw_uplink_ctrl_teid = get_new_ctrl_teid();
   //Setup uplink user TEID
   uint64_t spgw_uplink_user_teid = get_new_user_teid();
-  //Allocate UE IP XXX TODO check for valid non-zero address and return error code
-  in_addr_t ue_ip = get_new_ue_ipv4(cs_req->imsi);
+  //Allocate UE IP
+  in_addr_t ue_ip = get_new_ue_ipv4();
+  //in_addr_t ue_ip = inet_addr("172.16.0.2");
   uint8_t default_bearer_id = 5;
 
   m_spgw_log->console("SPGW: Allocated Ctrl TEID %" PRIu64 "\n", spgw_uplink_ctrl_teid);
