diff --git a/lib/include/srslte/common/block_queue.h b/lib/include/srslte/common/block_queue.h
index 7de09298..080f39fb 100644
--- a/lib/include/srslte/common/block_queue.h
+++ b/lib/include/srslte/common/block_queue.h
@@ -39,6 +39,8 @@
 #include <unistd.h>
 #include <strings.h>
 
+#include "srslte/common/queue_metrics.h"
+
 namespace srslte {
 
 template<typename myobj>
@@ -61,6 +63,7 @@ public:
     mutexed_callback = NULL;
     enable = true;
     num_threads = 0;
+    qmetrics.capacity = capacity;
   }
   ~block_queue() {
     // Unlock threads waiting at push or pop
@@ -86,7 +89,10 @@ public:
     mutexed_callback = itf;
   }
   void resize(int new_capacity) {
+    pthread_mutex_lock(&mutex);
     capacity = new_capacity;
+    qmetrics.capacity = capacity;
+    pthread_mutex_unlock(&mutex);
   }
 
   void push(const myobj& value) {
@@ -116,7 +122,9 @@ public:
 
   void clear() { // remove all items
     myobj *item = NULL;
-    while (try_pop(item));
+    while (try_pop(item)) {
+      ++qmetrics.num_cleared;
+    }
   }
 
   myobj front() {
@@ -124,31 +132,50 @@ public:
   }
 
   size_t size() {
-    return q.size();
+    pthread_mutex_lock(&mutex);
+    size_t result = q.size();
+    pthread_mutex_unlock(&mutex);
+    return result;
   }
 
+  queue_metrics_t get_qmetrics(bool bReset = false) {
+    pthread_mutex_lock(&mutex);
+    const queue_metrics_t result = qmetrics;
+    if(bReset) {
+      qmetrics.reset();
+    }
+    pthread_mutex_unlock(&mutex);
+    return result;
+  }
+   
 private:
 
   bool pop_(myobj *value, bool block) {
     if (!enable) {
+      ++qmetrics.num_pop_fail;
       return false;
     }
     pthread_mutex_lock(&mutex);
     num_threads++;
     bool ret = false;
     if (q.empty() && !block) {
+      ++qmetrics.num_pop_fail;
       goto exit;
     }
     while (q.empty() && enable) {
       pthread_cond_wait(&cv_empty, &mutex);
     }
     if (!enable) {
+      ++qmetrics.num_pop_fail;
       goto exit;
     }
     if (value) {
       *value = q.front();
     }
     q.pop();
+    ++qmetrics.num_pop;
+    qmetrics.currsize = q.size();
+
     ret = true;
     if (mutexed_callback) {
       mutexed_callback->popping(*value);
@@ -162,6 +189,7 @@ private:
 
   bool push_(const myobj& value, bool block) {
     if (!enable) {
+      ++qmetrics.num_push_fail;
       return false;
     }
     pthread_mutex_lock(&mutex);
@@ -173,13 +201,19 @@ private:
           pthread_cond_wait(&cv_full, &mutex);
         }
         if (!enable) {
+          ++qmetrics.num_push_fail;
           goto exit;
         }
       } else if (q.size() >= (uint32_t) capacity) {
+        ++qmetrics.num_push_fail;
         goto exit;
       }
     }
     q.push(value);
+    ++qmetrics.num_push;
+    qmetrics.currsize = q.size();
+    qmetrics.highwater = std::max(qmetrics.highwater, q.size());
+
     ret = true;
     if (mutexed_callback) {
       mutexed_callback->pushing(value);
@@ -199,6 +233,7 @@ private:
   int capacity;
   bool enable;
   uint32_t num_threads;
+  queue_metrics_t qmetrics;
 };
 
 }
diff --git a/lib/include/srslte/common/queue_metrics.h b/lib/include/srslte/common/queue_metrics.h
new file mode 100644
index 00000000..15727f82
--- /dev/null
+++ b/lib/include/srslte/common/queue_metrics.h
@@ -0,0 +1,120 @@
+/**
+ *
+ * \section COPYRIGHT
+ *
+ * Copyright (c) 2019 - Adjacent Link LLC, Bridgewater, New Jersey
+ *
+ * \section LICENSE
+ *
+ * This file is part of the srsLTE library.
+ *
+ * srsLTE is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as
+ * published by the Free Software Foundation, either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * srsLTE is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * A copy of the GNU Affero General Public License can be found in
+ * the LICENSE file in the top-level directory of this distribution
+ * and at http://www.gnu.org/licenses/.
+ *
+ */
+
+/**
+ *
+ * \section COPYRIGHT
+ *
+ * Copyright 2015 The srsUE Developers. See the
+ * COPYRIGHT file at the top-level directory of this distribution.
+ *
+ * \section LICENSE
+ *
+ * This file is part of the srsUE library.
+ *
+ * srsUE is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as
+ * published by the Free Software Foundation, either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * srsUE is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * A copy of the GNU Affero General Public License can be found in
+ * the LICENSE file in the top-level directory of this distribution
+ * and at http://www.gnu.org/licenses/.
+ *
+ */
+
+/******************************************************************************
+ *  File:         qmetrics.h
+ *  Description:  Generic queue metrics
+ *               
+ *              
+ *****************************************************************************/
+
+
+#ifndef QUEUE_METRICS_H
+#define QUEUE_METRICS_H
+
+#include <sstream>
+
+namespace srslte {
+
+  struct queue_metrics_t {
+   int    capacity;
+   size_t currsize;
+   size_t highwater;
+   size_t num_cleared;
+   size_t num_push;
+   size_t num_push_fail;
+   size_t num_pop;
+   size_t num_pop_fail;
+
+   queue_metrics_t() { 
+     reset();
+   }
+
+   void reset() {
+    capacity = 0;
+    currsize = 0;
+    highwater = 0;
+    num_cleared = 0;
+    num_push = 0;
+    num_push_fail = 0;
+    num_pop = 0;
+    num_pop_fail = 0;
+   }
+
+   std::string toString() const
+    {
+      std::stringstream ss;
+
+      ss << "cs=" 
+         << currsize
+         << ", hw="
+         << highwater
+         << ", cap="
+         << capacity
+         << ", nc="
+         << num_cleared
+         << ", npu="
+         << num_push
+         << ", npuf="
+         << num_push_fail
+         << ", npo="
+         << num_pop
+         << ", npof="
+         << num_pop_fail;
+
+       return ss.str();
+    }
+ };
+}
+
+#endif // QUEUE_METRICS_H
diff --git a/lib/include/srslte/interfaces/enb_metrics_interface.h b/lib/include/srslte/interfaces/enb_metrics_interface.h
index 31bd5e1e..1f527566 100644
--- a/lib/include/srslte/interfaces/enb_metrics_interface.h
+++ b/lib/include/srslte/interfaces/enb_metrics_interface.h
@@ -48,6 +48,7 @@ typedef struct {
   mac_metrics_t   mac[ENB_METRICS_MAX_USERS];
   rrc_metrics_t   rrc; 
   s1ap_metrics_t  s1ap;
+  srslte::rlc_metrics_t rlc[ENB_METRICS_MAX_USERS];
   bool            running;
 }enb_metrics_t;
 
diff --git a/lib/include/srslte/upper/rlc_am.h b/lib/include/srslte/upper/rlc_am.h
index 226fa035..00d19019 100644
--- a/lib/include/srslte/upper/rlc_am.h
+++ b/lib/include/srslte/upper/rlc_am.h
@@ -93,6 +93,7 @@ public:
   uint32_t get_num_rx_bytes();
   void reset_metrics();
 
+  queue_metrics_t get_qmetrics(bool bReset);
 private:
 
   // Transmitter sub-class
@@ -123,6 +124,7 @@ private:
     // Interface for Rx subclass
     void handle_control_pdu(uint8_t *payload, uint32_t nof_bytes);
 
+    queue_metrics_t get_qmetrics(bool bReset);
   private:
 
     int  build_status_pdu(uint8_t *payload, uint32_t nof_bytes);
diff --git a/lib/include/srslte/upper/rlc_common.h b/lib/include/srslte/upper/rlc_common.h
index 6c69b92a..af2ca01b 100644
--- a/lib/include/srslte/upper/rlc_common.h
+++ b/lib/include/srslte/upper/rlc_common.h
@@ -168,6 +168,7 @@ public:
   virtual uint32_t get_buffer_state() = 0;
   virtual int      read_pdu(uint8_t *payload, uint32_t nof_bytes) = 0;
   virtual void     write_pdu(uint8_t *payload, uint32_t nof_bytes) = 0;
+  virtual queue_metrics_t get_qmetrics(bool bReset = false) = 0;
 };
 
 } // namespace srslte
diff --git a/lib/include/srslte/upper/rlc_metrics.h b/lib/include/srslte/upper/rlc_metrics.h
index 5e2d69c1..43e7aaa6 100644
--- a/lib/include/srslte/upper/rlc_metrics.h
+++ b/lib/include/srslte/upper/rlc_metrics.h
@@ -23,14 +23,25 @@
 #define SRSLTE_RLC_METRICS_H
 
 #include "srslte/common/common.h"
+#include "srslte/common/queue_metrics.h"
+#include "srslte/upper/rlc_interface.h"
 
 namespace srslte {
 
+struct rlc_queue_metrics_t { 
+ queue_metrics_t qmetrics;
+ rlc_mode_t      mode;
+};
+
+
 struct rlc_metrics_t
 {
   float dl_tput_mbps[SRSLTE_N_RADIO_BEARERS];
   float ul_tput_mbps[SRSLTE_N_RADIO_BEARERS];
   float dl_tput_mrb_mbps[SRSLTE_N_MCH_LCIDS];
+
+  rlc_queue_metrics_t metrics[SRSLTE_N_MCH_LCIDS];
+  rlc_queue_metrics_t mrb_metrics[SRSLTE_N_MCH_LCIDS];
 };
 
 } // namespace srslte
diff --git a/lib/include/srslte/upper/rlc_tm.h b/lib/include/srslte/upper/rlc_tm.h
index 8d3b9375..820ababb 100644
--- a/lib/include/srslte/upper/rlc_tm.h
+++ b/lib/include/srslte/upper/rlc_tm.h
@@ -62,6 +62,7 @@ public:
   int      read_pdu(uint8_t *payload, uint32_t nof_bytes);
   void     write_pdu(uint8_t *payload, uint32_t nof_bytes);
 
+  queue_metrics_t get_qmetrics(bool bReset = false);
 private:
 
   byte_buffer_pool          *pool;
diff --git a/lib/include/srslte/upper/rlc_tx_queue.h b/lib/include/srslte/upper/rlc_tx_queue.h
index 9eafa832..115eda27 100644
--- a/lib/include/srslte/upper/rlc_tx_queue.h
+++ b/lib/include/srslte/upper/rlc_tx_queue.h
@@ -109,6 +109,9 @@ public:
     return queue.empty();
   }
 
+  queue_metrics_t get_qmetrics(bool bReset = false) {
+    return queue.get_qmetrics(bReset);
+  }
 private:
 
   block_queue<byte_buffer_t*> queue;
diff --git a/lib/include/srslte/upper/rlc_um.h b/lib/include/srslte/upper/rlc_um.h
index df179a34..a8093f3e 100644
--- a/lib/include/srslte/upper/rlc_um.h
+++ b/lib/include/srslte/upper/rlc_um.h
@@ -73,6 +73,7 @@ public:
   uint32_t get_num_rx_bytes();
   void reset_metrics();
 
+  queue_metrics_t get_qmetrics(bool bReset = false);
 private:
 
   // Transmitter sub-class
@@ -94,6 +95,8 @@ private:
     bool has_data();
     uint32_t get_buffer_state();
 
+    queue_metrics_t get_qmetrics(bool bReset = false);
+
   private:
     byte_buffer_pool        *pool;
     srslte::log             *log;
diff --git a/lib/src/upper/rlc.cc b/lib/src/upper/rlc.cc
index f33f6386..d433128e 100644
--- a/lib/src/upper/rlc.cc
+++ b/lib/src/upper/rlc.cc
@@ -113,18 +113,26 @@ void rlc::get_metrics(rlc_metrics_t &m)
   for (rlc_map_t::iterator it = rlc_array.begin(); it != rlc_array.end(); ++it) {
     m.dl_tput_mbps[it->first] = (it->second->get_num_rx_bytes()*8/static_cast<double>(1e6))/secs;
     m.ul_tput_mbps[it->first] = (it->second->get_num_tx_bytes()*8/static_cast<double>(1e6))/secs;
-    rlc_log->info("LCID=%d, RX throughput: %4.6f Mbps. TX throughput: %4.6f Mbps.\n",
+    m.metrics[it->first].qmetrics = it->second->get_qmetrics();
+    m.metrics[it->first].mode = it->second->get_mode();
+    rlc_log->info("LCID=%d, RX throughput: %4.6f Mbps. TX throughput: %4.6f Mbps. mode %s, %s\n",
                     it->first,
                     (it->second->get_num_rx_bytes()*8/static_cast<double>(1e6))/secs,
-                    (it->second->get_num_tx_bytes()*8/static_cast<double>(1e6))/secs);
+                    (it->second->get_num_tx_bytes()*8/static_cast<double>(1e6))/secs,
+                    rlc_mode_text[it->second->get_mode()],
+                    m.metrics[it->first].qmetrics.toString().c_str());
   }
 
   // Add multicast metrics
   for (rlc_map_t::iterator it = rlc_array_mrb.begin(); it != rlc_array_mrb.end(); ++it) {
     m.dl_tput_mbps[it->first] = (it->second->get_num_rx_bytes()*8/static_cast<double>(1e6))/secs;
-    rlc_log->info("MCH_LCID=%d, RX throughput: %4.6f Mbps\n",
+    m.mrb_metrics[it->first].qmetrics = it->second->get_qmetrics();
+    m.mrb_metrics[it->first].mode = it->second->get_mode();
+    rlc_log->info("MCH_LCID=%d, RX throughput: %4.6f Mbps. mode %s, %s\n",
                   it->first,
-                  (it->second->get_num_rx_bytes()*8/static_cast<double>(1e6))/secs);
+                  (it->second->get_num_rx_bytes()*8/static_cast<double>(1e6))/secs,
+                  rlc_mode_text[it->second->get_mode()],
+                  m.mrb_metrics[it->first].qmetrics.toString().c_str());
   }
 
   memcpy(&metrics_time[1], &metrics_time[2], sizeof(struct timeval));
diff --git a/lib/src/upper/rlc_am.cc b/lib/src/upper/rlc_am.cc
index 2c2810ab..8e8f4928 100644
--- a/lib/src/upper/rlc_am.cc
+++ b/lib/src/upper/rlc_am.cc
@@ -124,6 +124,11 @@ void rlc_am::reset_metrics()
   rx.reset_metrics();
 }
 
+queue_metrics_t rlc_am::get_qmetrics(bool bReset)
+{
+  return tx.get_qmetrics(bReset);
+}
+
 /****************************************************************************
  * PDCP interface
  ***************************************************************************/
@@ -1134,7 +1139,10 @@ bool rlc_am::rlc_am_tx::retx_queue_has_sn(uint32_t sn)
   return false;
 }
 
-
+queue_metrics_t rlc_am::rlc_am_tx::get_qmetrics(bool bReset)
+{
+  return tx_sdu_queue.get_qmetrics(bReset);
+}
 
 /****************************************************************************
  * Rx subclass implementation
diff --git a/lib/src/upper/rlc_tm.cc b/lib/src/upper/rlc_tm.cc
index 11aa4412..d8b12692 100644
--- a/lib/src/upper/rlc_tm.cc
+++ b/lib/src/upper/rlc_tm.cc
@@ -188,4 +188,9 @@ void rlc_tm::write_pdu(uint8_t *payload, uint32_t nof_bytes)
   }
 }
 
+queue_metrics_t rlc_tm::get_qmetrics(bool bReset)
+{
+  return ul_queue.get_qmetrics(bReset);
+}
+
 } // namespace srsue
diff --git a/lib/src/upper/rlc_um.cc b/lib/src/upper/rlc_um.cc
index bec8f1d1..10e0cc60 100644
--- a/lib/src/upper/rlc_um.cc
+++ b/lib/src/upper/rlc_um.cc
@@ -189,6 +189,10 @@ void rlc_um::reset_metrics()
   rx.reset_metrics();
 }
 
+queue_metrics_t rlc_um::get_qmetrics(bool bReset)
+{
+  return tx.get_qmetrics(bReset);
+}
 
 /****************************************************************************
  * Helper functions
@@ -498,6 +502,12 @@ void rlc_um::rlc_um_tx::debug_state()
   log->debug("%s vt_us = %d\n", get_rb_name(), vt_us);
 }
 
+
+queue_metrics_t rlc_um::rlc_um_tx::get_qmetrics(bool bReset)
+{
+  return tx_sdu_queue.get_qmetrics(bReset);
+}
+
 /****************************************************************************
  * Rx subclass implementation
  ***************************************************************************/
diff --git a/srsenb/hdr/upper/rlc.h b/srsenb/hdr/upper/rlc.h
index bf8bd69c..37072533 100644
--- a/srsenb/hdr/upper/rlc.h
+++ b/srsenb/hdr/upper/rlc.h
@@ -23,6 +23,7 @@
 #include "srslte/interfaces/ue_interfaces.h"
 #include "srslte/interfaces/enb_interfaces.h"
 #include "srslte/upper/rlc.h"
+#include "srslte/upper/rlc_metrics.h"
 
 #ifndef SRSENB_RLC_H
 #define SRSENB_RLC_H
@@ -65,6 +66,8 @@ public:
   void write_pdu(uint16_t rnti, uint32_t lcid, uint8_t *payload, uint32_t nof_bytes);
   void read_pdu_pcch(uint8_t *payload, uint32_t buffer_size); 
   
+  void get_metrics(srslte::rlc_metrics_t * mlist);
+
 private: 
   
   class user_interface : public srsue::pdcp_interface_rlc, 
diff --git a/srsenb/src/enb.cc b/srsenb/src/enb.cc
index 44b7bf7e..82bba6e6 100644
--- a/srsenb/src/enb.cc
+++ b/srsenb/src/enb.cc
@@ -352,6 +352,7 @@ bool enb::get_metrics(enb_metrics_t &m)
   mac.get_metrics(m.mac);
   rrc.get_metrics(m.rrc);
   s1ap.get_metrics(m.s1ap);
+  rlc.get_metrics(m.rlc);
 
   m.running = started;  
   return true;
diff --git a/srsenb/src/metrics_stdout.cc b/srsenb/src/metrics_stdout.cc
index ffd0b269..d41a58d8 100644
--- a/srsenb/src/metrics_stdout.cc
+++ b/srsenb/src/metrics_stdout.cc
@@ -69,6 +69,50 @@ void metrics_stdout::set_metrics(enb_metrics_t &metrics, const uint32_t period_u
   std::ios::fmtflags f(cout.flags()); // For avoiding Coverity defect: Not restoring ostream format
 
   if (++n_reports > 10) {
+    for(uint16_t ue = 0; ue < metrics.rrc.n_ues; ++ue) {
+      cout << endl << "quemetrics:------------------------------------------------------------------------------------------------" << endl;
+
+      for(size_t n = 0; n < SRSLTE_N_RADIO_BEARERS; ++n) {
+         // use capacity to determine if lcid is active
+         if(metrics.rlc[ue].metrics[n].qmetrics.capacity) {
+             cout  << "rnti="      << std::setw(1) << metrics.mac[ue].rnti;
+             cout  << ", bearer"   << std::setw(2) << n;
+             cout  << ", mode="    << std::setw(1) << metrics.rlc[ue].metrics[n].mode;
+             cout  << ", cap="     << std::setw(3) << metrics.rlc[ue].metrics[n].qmetrics.capacity;
+             cout  << ", depth="   << std::setw(3) << metrics.rlc[ue].metrics[n].qmetrics.currsize;
+             cout  << ", hw="      << std::setw(3) << metrics.rlc[ue].metrics[n].qmetrics.highwater;
+             cout  << ", cleared=" << std::setw(3) << metrics.rlc[ue].metrics[n].qmetrics.num_cleared;
+             cout  << ", pushed="  << std::setw(3) << metrics.rlc[ue].metrics[n].qmetrics.num_push;
+             cout  << ", pusherr=" << std::setw(3) << metrics.rlc[ue].metrics[n].qmetrics.num_push_fail;
+             cout  << ", poped="   << std::setw(3) << metrics.rlc[ue].metrics[n].qmetrics.num_pop;
+             cout  << ", poperr="  << std::setw(3) << metrics.rlc[ue].metrics[n].qmetrics.num_pop_fail;
+             cout << endl;
+         }
+      }
+      cout << "-----------------------------------------------------------------------------------------------------------" << endl;
+
+      cout << endl << "mrb quemetrics:--------------------------------------------------------------------------------------------" << endl;
+
+      for(size_t n = 0; n < SRSLTE_N_MCH_LCIDS; ++n) {
+          // use capacity to determine if lcid is active
+          if(metrics.rlc[ue].mrb_metrics[n].qmetrics.capacity) {
+             cout  << "rnti="     << std::setw(1) << metrics.mac[ue].rnti;
+             cout << ", bearer"   << std::setw(2) << n;
+             cout << ", mode="    << std::setw(1) << metrics.rlc[ue].mrb_metrics[n].mode;
+             cout << ", cap="     << std::setw(3) << metrics.rlc[ue].mrb_metrics[n].qmetrics.capacity;
+             cout << ", depth="   << std::setw(3) << metrics.rlc[ue].mrb_metrics[n].qmetrics.currsize;
+             cout << ", hw="      << std::setw(3) << metrics.rlc[ue].mrb_metrics[n].qmetrics.highwater;
+             cout << ", cleared=" << std::setw(3) << metrics.rlc[ue].mrb_metrics[n].qmetrics.num_cleared;
+             cout << ", pushed="  << std::setw(3) << metrics.rlc[ue].mrb_metrics[n].qmetrics.num_push;
+             cout << ", pusherr=" << std::setw(3) << metrics.rlc[ue].mrb_metrics[n].qmetrics.num_push_fail;
+             cout << ", poped="   << std::setw(3) << metrics.rlc[ue].mrb_metrics[n].qmetrics.num_pop;
+             cout << ", poperr="  << std::setw(3) << metrics.rlc[ue].mrb_metrics[n].qmetrics.num_pop_fail;
+             cout << endl;
+           }
+        }
+      cout << "-----------------------------------------------------------------------------------------------------------" << endl;
+     }
+
     n_reports = 0;
     cout << endl;
     cout << "------DL------------------------------UL----------------------------------" << endl;
diff --git a/srsenb/src/upper/rlc.cc b/srsenb/src/upper/rlc.cc
index f64707df..666e6a27 100644
--- a/srsenb/src/upper/rlc.cc
+++ b/srsenb/src/upper/rlc.cc
@@ -243,4 +243,15 @@ std::string rlc::user_interface::get_rb_name(uint32_t lcid)
   return std::string(rb_id_text[lcid]);
 }
 
+void rlc::get_metrics(srslte::rlc_metrics_t *mlist)
+{
+  pthread_rwlock_rdlock(&rwlock);
+  size_t n = 0;
+  for(std::map<uint32_t, user_interface>::iterator iter=users.begin(); iter!=users.end(); ++iter) {
+    iter->second.rlc->get_metrics(mlist[n++]);
+  }
+  pthread_rwlock_unlock(&rwlock);
+}
+
+
 }
diff --git a/srsue/src/metrics_stdout.cc b/srsue/src/metrics_stdout.cc
index 7f77c522..bc5c8d53 100644
--- a/srsue/src/metrics_stdout.cc
+++ b/srsue/src/metrics_stdout.cc
@@ -70,6 +70,47 @@ void metrics_stdout::set_metrics(ue_metrics_t &metrics, const uint32_t period_us
 
   if(++n_reports > 10)
   {
+    cout << endl << "quemetrics:------------------------------------------------------------------------------------------------" << endl;
+
+    for(size_t n = 0; n < SRSLTE_N_RADIO_BEARERS; ++n) {
+       // use capacity to determine if lcid is active
+       if(metrics.rlc.metrics[n].qmetrics.capacity) {
+           cout  << "bearer"     << std::setw(2) << n;
+           cout  << ", mode="    << std::setw(1) << metrics.rlc.metrics[n].mode;
+           cout  << ", cap="     << std::setw(3) << metrics.rlc.metrics[n].qmetrics.capacity;
+           cout  << ", depth="   << std::setw(3) << metrics.rlc.metrics[n].qmetrics.currsize;
+           cout  << ", hw="      << std::setw(3) << metrics.rlc.metrics[n].qmetrics.highwater;
+           cout  << ", cleared=" << std::setw(3) << metrics.rlc.metrics[n].qmetrics.num_cleared;
+           cout  << ", pushed="  << std::setw(3) << metrics.rlc.metrics[n].qmetrics.num_push;
+           cout  << ", pusherr=" << std::setw(3) << metrics.rlc.metrics[n].qmetrics.num_push_fail;
+           cout  << ", poped="   << std::setw(3) << metrics.rlc.metrics[n].qmetrics.num_pop;
+           cout  << ", poperr="  << std::setw(3) << metrics.rlc.metrics[n].qmetrics.num_pop_fail;
+           cout << endl;
+       }
+    }
+    cout << "-----------------------------------------------------------------------------------------------------------" << endl;
+
+    cout << endl << "mrb quemetrics:--------------------------------------------------------------------------------------------" << endl;
+
+    for(size_t n = 0; n < SRSLTE_N_MCH_LCIDS; ++n) {
+        // use capacity to determine if lcid is active
+        if(metrics.rlc.mrb_metrics[n].qmetrics.capacity) {
+           cout << "bearer"     << std::setw(2) << n;
+           cout << ", mode="    << std::setw(1) << metrics.rlc.mrb_metrics[n].mode;
+           cout << ", cap="     << std::setw(3) << metrics.rlc.mrb_metrics[n].qmetrics.capacity;
+           cout << ", depth="   << std::setw(3) << metrics.rlc.mrb_metrics[n].qmetrics.currsize;
+           cout << ", hw="      << std::setw(3) << metrics.rlc.mrb_metrics[n].qmetrics.highwater;
+           cout << ", cleared=" << std::setw(3) << metrics.rlc.mrb_metrics[n].qmetrics.num_cleared;
+           cout << ", pushed="  << std::setw(3) << metrics.rlc.mrb_metrics[n].qmetrics.num_push;
+           cout << ", pusherr=" << std::setw(3) << metrics.rlc.mrb_metrics[n].qmetrics.num_push_fail;
+           cout << ", poped="   << std::setw(3) << metrics.rlc.mrb_metrics[n].qmetrics.num_pop;
+           cout << ", poperr="  << std::setw(3) << metrics.rlc.mrb_metrics[n].qmetrics.num_pop_fail;
+           cout << endl;
+         }
+      }
+    cout << "-----------------------------------------------------------------------------------------------------------" << endl;
+
+
     n_reports = 0;
     cout << endl;
     cout << "----Signal--------------DL-------------------------------------UL----------------------" << endl;
@@ -107,6 +148,8 @@ void metrics_stdout::set_metrics(ue_metrics_t &metrics, const uint32_t period_us
   if (metrics.rf.rf_error) {
     printf("RF status: O=%d, U=%d, L=%d\n", metrics.rf.rf_o, metrics.rf.rf_u, metrics.rf.rf_l);
   }
+
+
 }
 
 std::string metrics_stdout::float_to_string(float f, int digits)
