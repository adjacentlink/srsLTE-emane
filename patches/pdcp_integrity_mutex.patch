diff --git a/lib/src/upper/pdcp_entity.cc b/lib/src/upper/pdcp_entity.cc
index ad1e97e..94038bb 100644
--- a/lib/src/upper/pdcp_entity.cc
+++ b/lib/src/upper/pdcp_entity.cc
@@ -28,6 +28,10 @@
 #include "srslte/upper/pdcp_entity.h"
 #include "srslte/common/security.h"
 
+namespace {
+  pthread_mutex_t mutex_ = PTHREAD_MUTEX_INITIALIZER;
+}
+
 namespace srslte {
 
 pdcp_entity::pdcp_entity()
@@ -250,6 +254,8 @@ void pdcp_entity::integrity_generate( uint8_t  *msg,
                                       uint32_t  msg_len,
                                       uint8_t  *mac)
 {
+  pthread_mutex_lock(&mutex_);
+
   switch(integ_algo)
   {
   case INTEGRITY_ALGORITHM_ID_EIA0:
@@ -275,6 +281,7 @@ void pdcp_entity::integrity_generate( uint8_t  *msg,
   default:
     break;
   }
+  pthread_mutex_unlock(&mutex_);
 
   log->debug("Integrity gen input:\n");
   log->debug_hex(&k_int[16], 16, "  K_int");
@@ -294,6 +301,8 @@ bool pdcp_entity::integrity_verify(uint8_t  *msg,
   uint8_t i = 0;
   bool isValid = true;
 
+  pthread_mutex_lock(&mutex_);
+
   switch(integ_algo)
   {
   case INTEGRITY_ALGORITHM_ID_EIA0:
@@ -349,6 +358,8 @@ bool pdcp_entity::integrity_verify(uint8_t  *msg,
     break;
   }
 
+  pthread_mutex_unlock(&mutex_);
+
   return isValid;
 }
 
@@ -384,6 +395,7 @@ void pdcp_entity::cipher_encrypt(uint8_t  *msg,
   default:
     break;
   }
+  pthread_mutex_unlock(&mutex_);
 }
 
 void pdcp_entity::cipher_decrypt(uint8_t  *ct,
